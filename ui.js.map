{"version":3,"file":"ui.js","sources":["../node_modules/cfgrammar-tool/types.js","../node_modules/cfgrammar-tool/assert.js","../node_modules/cfgrammar-tool/generate.js","../node_modules/cfgrammar-tool/algorithms.js","../node_modules/cfgrammar-tool/parser.js","../node_modules/cfgrammar-tool/check.js","../node_modules/cfgrammar-tool/printers.js","../node_modules/cfgrammar-tool/index.js","../src/dfa-lib.js","../src/regex.js","../src/ui.js"],"sourcesContent":["function Sym(type, data) {\n  this.type = type;\n  this.data = data; \n}\nSym.prototype.equals = function(other) {\n  return other.type === this.type && other.data === this.data;\n}\nSym.prototype.toString = function(){ \n  return this.data.toString(); //return this.type + '(' + this.data + ')';\n}\n\nfunction NT(data) { return new Sym('NT', data); }\nfunction T(data) { return new Sym('T', data); }\n\nfunction reprEscape(str) { // does not handle unicode or exceptional cases properly.\n  return str.replace(/['\\\\]/g, function(c) { return '\\\\' + c; })\n    .replace(/\\n/g, '\\\\n').replace(/\\r/g, '\\\\r');\n}\n\nfunction Rule(name, production) {\n  if(!(this instanceof Rule)) return new Rule(name, production);\n  this.name = name; // LHS\n  this.production = production; // RHS\\\n}\nRule.prototype.equals = function(other) {\n  if(other.name !== this.name) return false;\n  if(other.production.length !== this.production.length) return false;\n  \n  for(var i=0; i<other.production.length; ++i) {\n    if(!other.production[i].equals(this.production[i])) return false;\n  }\n  return true;\n}\nRule.prototype.toString = function() {\n  return this.name + ' -> ' + this.production.join('');\n}\nRule.prototype.repr = function() {\n  var out = 'Rule(\\'' + reprEscape(this.name) + '\\', [';\n  for(var i=0; i<this.production.length; ++i) {\n    if(i>0) out += ', ';\n    out += this.production[i].type + '(\\'' + reprEscape(this.production[i].data) + '\\')';\n  }\n  out += '])';\n  return out;\n}\n\n\n\n\nfunction Grammar(rules, start) { // if not given, start is LHS of the first rule.\n  if(!(this instanceof Grammar)) return new Grammar(rules, start);\n  this.rules = rules;\n  this.start = start || rules[0].name; // TODO warn\n  this.symbolMap = {}; // initially just rules for each symbol; eventually can contain annotations like 'nullable'\n  this.symbolsList = start?[start]:[];\n  \n  if(start) this.symbolMap[start] = {rules: []};\n  \n  for(var i=0; i<this.rules.length; ++i) {\n    var sym = this.rules[i].name;\n    if(!(sym in this.symbolMap)) {\n      this.symbolMap[sym] = {rules: []};\n      this.symbolsList.push(sym);\n    }\n    \n    for(var j=0; j<this.rules[i].production.length; ++j) {\n      var rhsSym = this.rules[i].production[j];\n      if(rhsSym.type == 'NT' && !(rhsSym.data in this.symbolMap)) {\n        this.symbolMap[rhsSym.data] = {rules: []};\n        this.symbolsList.push(rhsSym.data);\n      }\n    }\n    this.symbolMap[sym].rules.push(this.rules[i]);\n  }\n}\nGrammar.prototype.repr = function() {\n  var out = 'Grammar([\\n  ';\n  for(var i=0; i<this.rules.length; ++i) {\n    if(i>0) out += ',\\n  ';\n    out += this.rules[i].repr();\n  }\n  out += '\\n], \\'' + reprEscape(this.start) + '\\')';\n  return out;\n}\n\n\n// get a map from symbols to a list of the rules they appear in the RHS of\n// if a symbol appears in a RHS more than once, that rule will appear more than once in the list\n// modifies the grammar to have _reverseMap property, for caching\nGrammar.prototype.getReverseMap = function() {\n  if(!this.hasOwnProperty('_reverseMap')) {\n    this._reverseMap = {};\n    for(var i=0; i<this.symbolsList.length; ++i) {\n      this._reverseMap[this.symbolsList[i]] = [];\n    }\n    for(var i=0; i<this.rules.length; ++i) {\n      var rule = this.rules[i];\n      for(var j=0; j<rule.production.length; ++j) {\n        if(rule.production[j].type === 'NT') {\n          this._reverseMap[rule.production[j].data].push(rule);\n        }\n      }\n    }\n  }\n  \n  return this._reverseMap;\n}\n\n\n\nmodule.exports = {\n  Sym: Sym,\n  NT: NT,\n  T: T,\n  Rule: Rule,\n  Grammar: Grammar\n}","module.exports = function(condition, message) {\n  if(!condition) {\n    throw new Error(message);\n  }\n}\n","// taken directly from http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.32.8707\n\nvar assert = require('./assert');\n\nfunction sum(l) {\n  var out = 0;\n  for(var i=0; i<l.length; ++i) {\n    out += l[i];\n  }\n  return out;\n}\n\nfunction choose(l, r) { // choose an entry from a list at random. should be passed a random number.\n  var total = sum(l);\n  if(total == 0) return -1; // no valid options\n  for(var i=0; i<l.length; ++i) {\n    var t = l[i]/total;\n    if(r < t) return i;\n    r -= t;\n  }\n  console.log('No choices? This shouldn\\'t really happen.', r);\n  return l.length-1;\n}\n\n\nfunction generatorFactory(grammar, deterministic) {\n  grammar = grammar.deNulled();\n  if(!grammar.empty && grammar.annotateSelfDeriving().length > 0) {\n    throw Error('Generator does not work when there are infinitely many parses for a string. (ie, when A*=>A is possible.)');\n  }\n  \n  var rand = !deterministic ? Math.random : (function() {\n    var seed = 0x2F6E2B1;\n    return function() {\n      // Robert Jenkins' 32 bit integer hash function. From Octane / V8.\n      seed = ((seed + 0x7ED55D16) + (seed << 12))  & 0xFFFFFFFF;\n      seed = ((seed ^ 0xC761C23C) ^ (seed >>> 19)) & 0xFFFFFFFF;\n      seed = ((seed + 0x165667B1) + (seed << 5))   & 0xFFFFFFFF;\n      seed = ((seed + 0xD3A2646C) ^ (seed << 9))   & 0xFFFFFFFF;\n      seed = ((seed + 0xFD7046C5) + (seed << 3))   & 0xFFFFFFFF;\n      seed = ((seed ^ 0xB55A4F09) ^ (seed >>> 16)) & 0xFFFFFFFF;\n      return (seed & 0xFFFFFFF) / 0x10000000;\n    };\n  }());\n\n  var ftable = {};\n  function f(sym, n) {\n    if(!(sym in ftable)) {\n      ftable[sym] = {};\n    }\n    if(n in ftable[sym]) {\n      return ftable[sym][n];\n    }\n  \n    var out = [];\n    for(var j=0; j<grammar.symbolMap[sym].rules.length; ++j) {\n      out.push(sum(fprime(sym, j, 0, n)));\n    }\n  \n    ftable[sym][n] = out;\n    return out;\n  }\n\n  var fprimetable = {};\n  function fprime(sym, j, k, n) {\n    if(n == 0) return [];\n  \n    if(!(sym in fprimetable)) {\n      fprimetable[sym] = {};\n    }\n    if(!(j in fprimetable[sym])) {\n      fprimetable[sym][j] = {};\n    }\n    if(!(k in fprimetable[sym][j])) {\n      fprimetable[sym][j][k] = {};\n    }\n    if(n in fprimetable[sym][j][k]) {\n      return fprimetable[sym][j][k][n];\n    }\n  \n    var x = grammar.symbolMap[sym].rules[j].production[k];\n    var tij = grammar.symbolMap[sym].rules[j].production.length-1;\n    var out;\n    if(x.type == 'T') {\n      if(k == tij) { // basically, if we are being asked about the last symbol\n        if(n == 1) { // paper has n=0. pretty sure that's a typo.\n          out = [1];\n        }\n        else {\n          out = [0];\n        }\n      }\n      else {\n        out = [sum(fprime(sym, j, k+1, n-1))];\n      }\n    }\n    else {\n      if(k == tij) {\n        out = [sum(f(x.data, n))];\n      }\n      else {\n        out = [];\n        for(var l=1; l<=n-tij+k; ++l) {\n          out.push(sum(f(x.data, l)) * sum(fprime(sym, j, k+1, n-l)));\n        }\n      }\n    }\n  \n    fprimetable[sym][j][k][n] = out;\n    return out;\n  }\n\n\n\n  function g(sym, n) {\n    var r = choose(f(sym, n), rand());\n    if(r == -1) return null; // no valid options\n    return gprime(sym, r, 0, n);\n  }\n\n\n  function gprime(sym, j, k, n) {\n    var x = grammar.symbolMap[sym].rules[j].production[k];\n    //console.log(sym, j, k, n, x)\n    var tij = grammar.symbolMap[sym].rules[j].production.length-1;\n  \n    if(x.type == 'T') {\n      if(k == tij) {\n        return [x.data];\n      }\n      else {\n        return [x.data].concat(gprime(sym, j, k+1, n-1));\n      }\n    }\n    else {\n      if(k == tij) {\n        return g(x.data, n);\n      }\n      else {\n        var l = choose(fprime(sym, j, k, n), rand()); // paper has i, i, k, n. pretty sure that's a typo\n        assert(l !== -1, \"Couldn't find a valid choice.\");\n        return g(x.data, l+1).concat(gprime(sym, j, k+1, n-(l+1))); // l is a length, not an index\n      }\n    }\n  }\n\n\n  function generate(n, opts) {\n    var asList = opts != null && opts.list;\n    if(n == 0) {\n      return grammar.makesEpsilon ? asList ? [] : '' : null;\n    }\n    if(grammar.empty) {\n      return null;\n    }\n    var outList = g(grammar.start, n);\n    if (outList == null) {\n      return null;\n    }\n    return asList ? outList : outList.join('');\n  }\n  \n  // TODO probably get rid of this.\n  // determine if there are any strings in the grammar of length in [start, start+range)\n  // returns such an n, if one exists, or -1 if none exist, or -2 if the language is {''},\n  // or -3 if the language is the empty set.\n  // by default, start=0, range=10\n  generate.findLength = function(start, range) {\n    if(grammar.empty) {\n      return grammar.makesEpsilon?-2:-3;\n    }\n    start = start || 0;\n    range = range || 10;\n\n    if(start == 0 && grammar.makesEpsilon) {\n      return 0;\n    }\n\n    for(var n=start; n<start+range; ++n) {\n      if(choose(f(grammar.start, n), rand()) !== -1) {\n        return n;\n      }\n    }\n    \n    return -1;\n  }\n  \n  // In the range [start, start+range), which lengths are possible?\n  // Returns null if the grammar is empty.\n  // TODO could also tell people when the only possibility is the empty string...\n  generate.findLengths = function(start, range) {\n    start = start || 0;\n    range = range || 10;\n    if(grammar.empty) {\n      if(!grammar.makesEpsilon) {\n        return null;\n      }\n      else {\n        return start == 0 ? [0]:[];\n      }\n    }\n    \n    var lengths = [];\n    if(start == 0) {\n      if(grammar.makesEpsilon) {\n        lengths.push(0);\n      }\n      start = 1;\n    }\n    \n    for(var length = start; length<start+range; ++length) {\n      if(choose(f(grammar.start, length), rand()) !== -1) {\n        lengths.push(length);\n      }\n    }\n    \n    return lengths;\n  }\n  \n  return generate;\n}\n\n\nmodule.exports = generatorFactory;","var Rule = require('./types').Rule;\nvar assert = require('./assert');\n// pass in the Grammar constructor and its prototype will be modified to have various algorithms\nmodule.exports = function(Grammar) {\n\n\n// todo annotate almost-terminals, which are nonterminals which can only produce strings consisting only of terminals or strings consisting of terminals and nonterminals (other than itself) which are almost-terminal.\n// todo simplified and aggressive simplified. denulls, standardizes nonterminal names, standardizes rule ordering. aggressive simplified probably invokes a new 'stripped' fn: it reduces the number of rules by folding almost-terminal rules into the things which make them. obviously this can have exponential blowup.\n// possibly also try to remove redundant rules?\n\n\n\n// modify the grammar so each symbol has a 'nullable' property\n// and the grammar to have a 'nullables' property, a list of nullable symbols\n// returns the list of nullables\n// http://cstheory.stackexchange.com/a/2493\nGrammar.prototype.annotateNullables = function() {\n  if(this.hasOwnProperty('nullables')) return this.nullables; // already done, don't redo\n  \n  this.nullables = [];\n  var queue = [];\n  var cs = []; // count of non-distinct symbols in RHS of rule i currently marked non-nullable, which does not make for a good variable name\n  var rMap = this.getReverseMap();\n\n  for(var i=0; i<this.symbolsList.length; ++i) {\n    this.symbolMap[this.symbolsList[i]].nullable = false;\n  }\n  \n  for(var i=0; i<this.rules.length; ++i) {\n    var c = 0;\n    var rule = this.rules[i];\n    var maybeNullable = true; // does this rule produce a string with only nonterminals?\n    for(var j=0; j<rule.production.length; ++j) {\n      if(rule.production[j].type === 'NT') {\n        ++c;\n      }\n      else {\n        maybeNullable = false;\n        break;\n      }\n    }\n    if(maybeNullable) {\n      cs.push(c);\n    }\n    else {\n      cs.push(0);\n    }\n    \n    \n    if(rule.production.length == 0 && !this.symbolMap[rule.name].nullable) {\n      this.symbolMap[rule.name].nullable = true;\n      queue.push(rule.name);\n      this.nullables.push(rule.name);\n    }\n  }\n\n  for(var i=0; i<this.rules.length; ++i) {\n    this.rules[i]._index = i;\n  }\n  \n  while(queue.length > 0) {\n    var cur = queue.pop();\n    for(var i=0; i<rMap[cur].length; ++i) {\n      var affected = rMap[cur][i];\n      if(--cs[affected._index] === 0 && !this.symbolMap[affected.name].nullable) { // can only have been positive if the rule contained no terminals, so ok\n        this.symbolMap[affected.name].nullable = true;\n        queue.push(affected.name);\n        this.nullables.push(affected.name);\n      }\n    }\n  }\n\n  for(var i=0; i<this.rules.length; ++i) {\n    delete this.rules[i]._index;\n  }\n\n  \n  return this.nullables;\n}\n\n\n// modify the grammar so each symbol has an \"unreachable\" property\n// ie, no chain of derivations from the start symbol reaches that symbol. note that something may be reachable even if no chain which produces a string involves that thing. (eg S -> AB, B->'', A->A. then B is reachable.)\n// grammar gets an \"unreachables\" property\n// returns the list of unreachables\nGrammar.prototype.annotateUnreachables = function() {\n  if(this.hasOwnProperty('unreachables')) return this.unreachables; // already done, don't redo\n  \n  this.unreachables = [];\n  var queue = [this.start];\n\n  for(var i=0; i<this.symbolsList.length; ++i) {\n    this.symbolMap[this.symbolsList[i]].unreachable = true;\n  }\n  this.symbolMap[this.start].unreachable = false;\n  \n\n  while(queue.length > 0) {\n    var cur = queue.pop();\n    for(var j=0; j<this.symbolMap[cur].rules.length; ++j) {\n      var rule = this.symbolMap[cur].rules[j];\n      for(var k=0; k<rule.production.length; ++k) {\n        var sym = rule.production[k];\n        if(sym.type === 'NT' && this.symbolMap[sym.data].unreachable) {\n          this.symbolMap[sym.data].unreachable = false;\n          queue.push(sym.data);\n        }\n      }\n    }\n  }\n  \n  for(var i=0; i<this.symbolsList.length; ++i) {\n    if(this.symbolMap[this.symbolsList[i]].unreachable) {\n      this.unreachables.push(this.symbolsList[i]);\n    }\n  }\n  \n  return this.unreachables;\n}\n\n\n// modify the grammar so each symbol has a \"useless\" property\n// ie, there is no terminal string derivable from that symbol\n// grammar gets a \"uselesses\" property (forgive me)\n// returns the list of useless symbols\nGrammar.prototype.annotateUseless = function() {\n  if(this.hasOwnProperty('uselesses')) return this.uselesses; // already done, don't redo\n  \n  this.uselesses = [];\n  var queue = [];\n  var cs = []; // count of non-distinct symbols in RHS of rule i currently marked possibly-useless, which does not make for a good variable name\n  var rMap = this.getReverseMap();\n\n  // very similar logic to finding nullables, except things are assumed useless until proven otherwise\n  for(var i=0; i<this.symbolsList.length; ++i) {\n    this.symbolMap[this.symbolsList[i]].useless = true;\n  }\n  \n  for(var i=0; i<this.rules.length; ++i) {\n    var c = 0;\n    var rule = this.rules[i];\n    for(var j=0; j<rule.production.length; ++j) {\n      if(rule.production[j].type === 'NT') {\n        ++c;\n      }\n    }\n    cs.push(c);\n    if(c == 0 && this.symbolMap[rule.name].useless) {\n      this.symbolMap[rule.name].useless = false;\n      queue.push(rule.name);\n    }\n  }\n\n  for(var i=0; i<this.rules.length; ++i) {\n    this.rules[i]._index = i;\n  }\n\n  \n  while(queue.length > 0) {\n    var cur = queue.pop();\n    for(var i=0; i<rMap[cur].length; ++i) {\n      var affected = rMap[cur][i];\n      if(--cs[affected._index] === 0 && this.symbolMap[affected.name].useless) {\n        this.symbolMap[affected.name].useless = false;\n        queue.push(affected.name);\n      }\n    }\n  }\n\n  for(var i=0; i<this.symbolsList.length; ++i) {\n    if(this.symbolMap[this.symbolsList[i]].useless) {\n      this.uselesses.push(this.symbolsList[i]);\n    }\n  }\n\n  for(var i=0; i<this.rules.length; ++i) {\n    delete this.rules[i]._index;\n  }\n  \n  return this.uselesses;\n}\n\n\n\n\n// modify the grammar so each symbol has a \"selfDeriving\" property\n// ie,  A *=> A (via some chain of length > 0)\n// grammar gets a \"selfDerivings\" property\n// returns the list of self-deriving symbols\n// http://cs.stackexchange.com/a/40967/12130\nGrammar.prototype.annotateSelfDeriving = function() {\n  if(this.hasOwnProperty('selfDerivings')) return this.selfDerivings; // already done, don't redo\n  \n  this.selfDerivings = [];\n  \n  this.annotateNullables();\n  \n  var derives = {}; // derives.A.B holds if A *=> B\n  for(var i=0; i<this.symbolsList.length; ++i) {\n    derives[this.symbolsList[i]] = {};\n  }\n  \n  \n  // initialization: set the one-step derivations.\n  o:for(var i=0; i<this.rules.length; ++i) {\n    var name = this.rules[i].name;\n    var production = this.rules[i].production;\n    \n    // easy cases: production empty, contains terminals, or contains exactly one nonterminal\n    if(production.length == 0) {\n      continue;\n    }\n    \n    for(var j=0; j<production.length; ++j) {\n      if(production[j].type == 'T') {\n        continue o;\n      }\n    }\n    \n    if(production.length == 1) {\n      derives[name][production[0].data] = true;\n      continue;\n    }\n    \n    \n    // harder case: production consists of two or more nonterminals. TODO could merge some loops but speedup is negligible probably\n    var nonnullable = null;\n    for(var j=0; j<production.length; ++j) {\n      if(!this.symbolMap[production[j].data].nullable) {\n        if(nonnullable !== null) {\n          continue o; // two or more nonnullable nonterminals: so this rule can't derive any single nonterminal\n        }\n        nonnullable = production[j].data;\n      }\n    }\n    \n    if(nonnullable !== null) { // exactly one nonnullable nonterminal: that and only that is derived.\n      derives[name][nonnullable] = true;\n    }\n    else { // two or more nullable: everything is derived\n      for(var j=0; j<production.length; ++j) {\n        derives[name][production[j].data] = true; // everything is a nonterminal, so this is safe\n      }\n    }\n  }\n  \n  // recursion: floyd-warshall, basically\n  for(var i=0; i<this.symbolsList.length; ++i) {\n    for(var j=0; j<this.symbolsList.length; ++j) {\n      for(var k=0; k<this.symbolsList.length; ++k) {\n        if(derives[this.symbolsList[i]][this.symbolsList[k]] && derives[this.symbolsList[k]][this.symbolsList[j]]) {\n          // if i derives k and k derives j then i derives j\n          derives[this.symbolsList[i]][this.symbolsList[j]] = true;\n        }\n      }\n    }\n  }\n  \n  for(var i=0; i<this.symbolsList.length; ++i) {\n    var cur = this.symbolsList[i];\n    if(derives[cur][cur]) {\n      this.symbolMap[cur].selfDeriving = true;\n      this.selfDerivings.push(cur);\n    }\n    else {\n      this.symbolMap[cur].selfDeriving = false;\n    }\n  }\n  \n  return this.selfDerivings;\n}\n\n\n\n\n\n\n\n// returns a copy of the grammar without useless symbols. does not modify the grammar,\n// except annotating. if the result is empty, returns {empty: true}.\nGrammar.prototype.strippedUseless = function() {\n  this.annotateUseless();\n  var newRules = [];\n  \n  for(var i=0; i<this.rules.length; ++i) {\n    var rule = this.rules[i];\n    if(!this.symbolMap[rule.name].useless) {\n      var j;\n      for(j=0; j<rule.production.length; ++j) {\n        if(rule.production[j].type == 'NT' && this.symbolMap[rule.production[j].data].useless) {\n          break;\n        }\n      }\n      if(j == rule.production.length) { // ie rule does not contain any useless symbols\n        newRules.push(rule);\n      }\n    }\n  }\n  \n  if(newRules.length == 0) {\n    return {empty: true};\n  }\n  \n  var newGrammar = Grammar(newRules, this.start);\n  if(newGrammar.symbolMap[newGrammar.start].rules.length === 0) {\n    return {empty: true}; // nowhere to go: empty.\n  }\n  \n  \n  assert(newGrammar.annotateUseless().length == 0, 'Haven\\'t actually eliminated all useless productions?');\n  \n  return newGrammar;\n}\n\n// returns a copy of the grammar without useless symbols. does not modify the grammar,\n// except annotating. if the result is empty, returns {empty: true}.\nGrammar.prototype.strippedUnreachable = function() {\n  this.annotateUnreachables();\n  var newRules = [];\n  for(var i=0; i<this.rules.length; ++i) {\n    var rule = this.rules[i];\n    if(!this.symbolMap[rule.name].unreachable) {\n      // sufficient that the LHS is unreachable, since RHS does not contain unreachable unless LHS is unreachable\n      newRules.push(rule);\n    }\n  }\n\n  if(newRules.length == 0) {\n    return {empty: true};\n  }\n  \n  var newGrammar = Grammar(newRules, this.start);\n  if(newGrammar.symbolMap[newGrammar.start].rules.length === 0) {\n    return {empty: true}; // nowhere to go: empty.\n  }\n  assert(newGrammar.annotateUnreachables().length == 0, 'Haven\\'t actually eliminated all unreachable productions?');\n  \n  return newGrammar;\n}\n\n\n// returns a copy of the grammar with unit productions removed (A -> B) removed.\n// does not modify the grammar. if the result is empty, returns {empty: true}.\nGrammar.prototype.strippedUnitProductions = function() {\n  var newRules = [];\n  \n  var done = [];\n  var queue = [];\n  function seen(rule) {\n    for(var i=0; i<done.length; ++i) {\n      if(done[i].equals(rule)) {\n        return true;\n      }\n    }\n    for(var i=0; i<queue.length; ++i) {\n      if(queue[i].equals(rule)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  \n  function enqueue(rule) {\n    if(!seen(rule)) {\n      queue.push(rule);\n    }\n  }\n  for(var i=0; i<this.rules.length; ++i) {\n    var rule = this.rules[i];\n    if(rule.production.length !== 1 || rule.production[0].type == 'T') {\n      newRules.push(rule);\n    }\n    else { // rule is of the form A->B\n      enqueue(rule);\n    }\n  }\n  \n  while(queue.length > 0) {\n    var rule = queue.pop();\n    done.push(rule);\n    var sym = rule.production[0].data; // everything in the queue is a unit production\n    if(sym !== rule.name) { // rule is not A->A, which can just be ignored\n      for(var j=0; j<this.symbolMap[sym].rules.length; ++j) {\n        var origRule = this.symbolMap[sym].rules[j]; // B->whatever\n        var newRule = Rule(rule.name, origRule.production.slice(0)); // A->whatever\n        if(newRule.production.length !==1 || newRule.production[0].type == 'T') {\n          newRules.push(newRule);\n        }\n        else {\n          enqueue(newRule);\n        }\n      }\n    }\n  }\n  \n  if(newRules.length == 0) {\n    return {empty: true};\n  }\n  \n  return Grammar(newRules, this.start); // I'm... pretty sure this is correct.\n}\n\n\n// returns a copy of the grammar with duplicate rules removed.\n// does not modify the grammar.\nGrammar.prototype.strippedDuplicates = function() {\n  var newRules = [];\n  for(var i=0; i<this.rules.length; ++i) {\n    var rule = this.rules[i];\n    var j;\n    for(j=0; j<newRules.length; ++j) {\n      if(newRules[j].equals(rule)) {\n        break;\n      }\n    }\n    if(j == newRules.length) {\n      newRules.push(rule);\n    }\n  }\n  return Grammar(newRules, this.start);\n}\n\n// TODO some testing about the proper order to strip things, to make grammar as small as possible.\n// returns a copy of the grammar without useless or unreachable symbols.\n// also removes duplicate rules and rules of the form A->B. does not modify the grammar,\n// except annotating. if the result is empty, returns {empty: true}.\nGrammar.prototype.stripped = function() {\n  var newGrammar = this.strippedUnitProductions();\n  if(newGrammar.empty) return newGrammar;\n\n  // useless, then unreachable. not the other way around.\n  newGrammar = newGrammar.strippedUseless();\n  if(newGrammar.empty) return newGrammar;\n  \n  newGrammar = newGrammar.strippedUnreachable();\n  if(newGrammar.empty) return newGrammar;\n\n  assert(newGrammar.annotateUseless().length == 0, 'Suddenly there are more useless symbols?');  \n  \n  newGrammar = newGrammar.strippedDuplicates();\n  return newGrammar;\n}\n\n\n\n// not exactly the world's most efficient implement, but whatever.\n// used in stripping nullables.\nfunction nthSubset(list, n) {\n  var out = [];\n  for(var i = 0, p = 1; p<=n; ++i, p<<=1) {\n    if(p & n) {\n      out.push(list[i]);\n    }\n  }\n  return out;\n}\n\n\n// returns a copy of the grammar which recognizes the same language (except without the empty string)\n// does not modify the grammar. new grammar has a property 'makesEpsilon' which is true iff epsilon\n// was recognized by the original grammar.\n// if the language is otherwise empty, returns {empty: true, makesEpsilon: [as appropriate]}\nGrammar.prototype.deNulled = function() {\n\n  var newGrammar = this.stripped();\n  if(newGrammar.empty) {\n    newGrammar.makesEpsilon = false;\n    return newGrammar;\n  }\n  \n  newGrammar.annotateNullables();\n  var makesEpsilon = newGrammar.symbolMap[newGrammar.start].nullable;\n  newRules = [];\n  for(var i=0; i<newGrammar.rules.length; ++i) {\n    var rule = newGrammar.rules[i];\n    if(rule.production.length == 0) {\n      continue; // do not add epsilon productions\n    }\n    var nullableRHSIndices = [];\n    for(var j=0; j<rule.production.length; ++j) {\n      if(rule.production[j].type == 'NT' && newGrammar.symbolMap[rule.production[j].data].nullable) {\n        nullableRHSIndices.push(j);\n      }\n    }\n    \n    if(nullableRHSIndices.length == 0) { // don't actually need this case, but meh.\n      newRules.push(rule);\n      continue;\n    }\n    \n    var skipFinal = (nullableRHSIndices.length == rule.production.length)?1:0; // if all X's are nullable, do not make an epsilon production.\n    var lastSubset = Math.pow(2, nullableRHSIndices.length) - skipFinal;\n    \n    // one new rule for each subset of nullable RHS symbols, omitting precisely that subset\n    for(var j = 0; j<lastSubset; ++j) {\n      var skippedSubset = nthSubset(nullableRHSIndices, j);\n      \n      var newProduction = [];\n      for(var k=0; k<rule.production.length; ++k) {\n        if(skippedSubset.indexOf(k) == -1) {\n          newProduction.push(rule.production[k]);\n        }\n      }\n      \n      newRules.push(Rule(rule.name, newProduction));\n    }\n    \n  }\n  \n  if(newRules.length == 0) {\n    return {empty: true, makesEpsilon: makesEpsilon};\n  }\n  \n  newGrammar = Grammar(newRules, newGrammar.start);\n  assert(newGrammar.annotateNullables().length == 0, 'Having removed nullables, there are still nullables.');\n  \n  newGrammar = newGrammar.stripped();\n  newGrammar.makesEpsilon = makesEpsilon;\n  \n  assert(newGrammar.empty || newGrammar.annotateSelfDeriving().length == 0, 'Removing nullables and unit productions did not prevent self-deriving, somehow.');\n  \n  return newGrammar;\n}\n\n// return a sorted string containing all of the terminals found in strings this grammar can produce.\nGrammar.prototype.alphabet = function() {\n  var deNulled = this.deNulled();\n  if (deNulled.empty) {\n    return '';\n  }\n  var alphabet = [];\n  deNulled.rules.forEach(function(r){\n    r.production.forEach(function(s){ if (s.type === 'T' && alphabet.indexOf(s.data) === -1) alphabet.push(s.data); });\n  });\n  return alphabet.sort().join('');\n}\n\n}\n","// http://cs.stackexchange.com/questions/40965/cfgs-detecting-infinitely-many-derivations-of-a-single-string\n// http://www.cs.laurentian.ca/jdompierre/html/MATH2056E_W2011/cours/s8.4_closures_relations_BW.pdf\n// https://a2c2a.wordpress.com/2014/09/18/implementing-an-earley-parser-that-handles-nullable-grammars-and-draws-all-unique-parse-trees-in-python/\n// http://web.stanford.edu/~crwong/cfg/grammar.html\n// http://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm\n\n\nvar assert = require('./assert');\nvar types = require('./types');\nrequire('./algorithms')(types.Grammar);\n\nvar parser = {};\n\nvar enums = {\n  DISTINCT: {},\n  SIMILAR: {},\n  IDENTICAL: {}, // ie, same rule, index, and predecessor, but different sub-parses\n  PRODUCEONE: {},\n  PRODUCETWO: {},\n  PRODUCEALL: {}\n}\nparser.PRODUCEONE = enums.PRODUCEONE;\nparser.PRODUCETWO = enums.PRODUCETWO;\nparser.PRODUCEALL = enums.PRODUCEALL; // TODO this should not be a global setting. if you really need, have different parse functions.\n\n\n\nparser.PRODUCECOUNT = enums.PRODUCETWO;\n\n// TODO this is not the best way of doing this.\nNT = types.NT;\nT = types.T;\nRule = types.Rule;\nGrammar = types.Grammar;\n\n\n// library code, woo\nfunction arraysEqual(a, b) {\n  if(a === b) return true;\n  if(a == null || b == null) return false;\n  if(a.length != b.length) return false;\n  for(var i = 0; i < a.length; ++i) {\n    if(a[i] !== b[i]) return false;\n  }\n  return true;\n}\n\n\n\n\n// a State in an Earley parse is a tuple (rule, index, predecessor, backPointers)\n// Conceptually, a State is a possibly-partial sub-parse of some part of the string.\n// 'rule' is the rule which this state is a (possibly partial) parse of\n// 'index' is how far along in the rule's production this state is\n// 'predecessor' is the index in the string-being-parsed at which this rule began\n// 'backPointers' is the children of this rule, essentially: that is,\n//   when index > 0, index has been pushed along by a series of sub-parses completing,\n//   each sub-parse representing a terminal or nonterminal in this rule's production.\n//   backPointers is an array containing those completed sub-parses/States.\n//   in particular, backPointers[i] is the State object corresponding to\n//   rule.production[i] (or null if said production is a terminal).\n// TODO rename backPointers, do away with index\n// TODO have 'c' instead of null for terminals in backPointers\nfunction State(rule, index, predecessor, backPointers) {\n  if(!(this instanceof State)) return new State(rule, index, predecessor, backPointers);\n  this.rule = rule;\n  this.index = index;\n  this.predecessor = predecessor;\n  this.backPointers = backPointers || [];\n  assert(this.index == this.backPointers.length); // honestly could just do away with index at this point\n}\nState.prototype.done = function(){ return this.index === this.rule.production.length; }\nState.prototype.compare = function(other) {\n  if(this.rule === other.rule\n  && this.index === other.index\n  && this.predecessor === other.predecessor) {\n    if(arraysEqual(this.backPointers, other.backPointers)) {\n      return enums.IDENTICAL;\n    }\n    else {\n      return enums.SIMILAR;\n    }\n  }\n  else {\n    return enums.DISTINCT;\n  }\n}\nState.prototype.next = function(){ return this.rule.production[this.index]; } \nState.prototype.toString = function(){\n  return '(' + this.rule.name + ' -> ' + this.rule.production.slice(0, this.index).join('')\n          + '*' + this.rule.production.slice(this.index).join('') + ', ' + this.predecessor.toString() + ')';\n}\n\n\n\n\n\n\n\nfunction parse(grammar, str, produceCount) {\n  if(typeof str !== 'string') throw Error('Can\\'t parse non-string object ' + (typeof str));\n  var oldProduceCount = parser.PRODUCECOUNT;\n  if(produceCount) {\n    parser.PRODUCECOUNT = produceCount;\n  }\n  \n  var chart = [];\n  for(var i=0; i<=str.length; ++i) chart.push([]);\n  \n  function seen(state, strPos) {\n    var count = 0;\n    for(var i=0; i<chart[strPos].length; ++i) {\n      var equalness = state.compare(chart[strPos][i]);\n      if(equalness == enums.IDENTICAL || (equalness == enums.SIMILAR && parser.PRODUCECOUNT == enums.PRODUCEONE)) { // either we've seen this exact thing before, or we've seen this modulo different parses and don't care about different parses\n        return true;\n      }\n      if(equalness == enums.SIMILAR && parser.PRODUCECOUNT == enums.PRODUCETWO && ++count > 1) { // we've seen something similar and do care\n        return true;\n      }\n    }\n    return false;\n  }\n  \n  function scanner(state, strPos) {\n    if(state.next().equals(T(str[strPos]))) {\n      var newBPs = state.backPointers.slice(0);\n      newBPs.push(null); // terminals do not need backpointers, of course\n      var advanced = State(state.rule, state.index+1, state.predecessor, newBPs);\n      if(!seen(advanced, strPos+1)) {\n        chart[strPos+1].push(advanced);\n      }\n    }\n  }\n  \n  function predictor(state, strPos) {\n    var sym = state.next();\n    for(var i=0; i<grammar.symbolMap[sym.data].rules.length; ++i) {\n      var advanced = State(grammar.symbolMap[sym.data].rules[i], 0, strPos);\n      if(!seen(advanced, strPos)) {\n        chart[strPos].push(advanced);\n      }\n    }\n    \n    // handle silly nullable cornercase: we might need to \"re-run\" completer for a nullable\n    // if we are predicting that nullable but it's already been processed\n    // given 'nullable' annotation, we could skip this when 'sym' is not nullable\n    for(var i=0; i<chart[strPos].length; ++i) { // can actually abort when we hit current state, but no real need (todo check speedup)\n      var candidate = chart[strPos][i];\n      if(candidate.rule.name === sym.data && candidate.predecessor === strPos && candidate.done()) {\n        var newBPs = state.backPointers.slice(0);\n        newBPs.push(candidate); // 'candidate' is already done\n        var advanced = State(state.rule, state.index+1, state.predecessor, newBPs);\n        if(!seen(advanced, strPos)) {\n          chart[strPos].push(advanced);\n        }\n      }\n    }\n  }\n  \n  function completer(state, strPos) {\n    var thisSym = NT(state.rule.name);\n    for(var i=0; i<chart[state.predecessor].length; ++i) {\n      var prevState = chart[state.predecessor][i];\n      if(!prevState.done() && thisSym.equals(prevState.next())) {\n        var newBPs = prevState.backPointers.slice(0);\n        newBPs.push(state); // just finished 'state'\n        var advanced = State(prevState.rule, prevState.index+1, prevState.predecessor, newBPs);\n        if(!seen(advanced, strPos)) {\n          chart[strPos].push(advanced);\n        }\n      }      \n    }\n  }\n  \n\n  if(parser.PRODUCECOUNT == enums.PRODUCEALL && grammar.annotateSelfDeriving().length !== 0) {\n    throw Error('Asked for all parses, but grammar can produce infinitely many parses for some string. Check grammar.annotateSelfDeriving() for specifics.');\n  }\n    \n  \n  var startSym = grammar.start;\n  var gammaRule = Rule(['GAMMA'], [NT(startSym)]); // needs a _unique_ identifier. Easiest way: new object\n  chart[0].push(State(gammaRule, 0, 0));\n  \n  for(var i=0; i<=str.length; ++i) {\n    for(var j=0; j<chart[i].length; ++j) {\n      var state = chart[i][j];\n      if(!state.done()) {\n        if(state.next().type == 'NT') {\n          predictor(state, i);\n        }\n        else {\n          scanner(state, i);\n        }\n      }\n      else {\n        completer(state, i);\n      }\n    }\n  }\n\n  // done constructing chart; time to find parses\n  var parses = [];\n  for(var i=0; i<chart[str.length].length; ++i) {\n    var state = chart[str.length][i];\n    if(state.rule === gammaRule && state.done()) {\n      parses.push(state);\n    }\n  }\n  \n  parser.PRODUCECOUNT = oldProduceCount;\n  return parses;\n}\n\nparser.parse = parse;\n\n\n\nmodule.exports = parser;\n","var assert = require('./assert');\nvar parser = require('./parser');\nvar generator = require('./generate');\n\n\n// Attempts to prove two grammars are different through the magic of fuzzing.\n// If it finds a string s which is accepted by one but not the other,\n// returns {string: s, acceptedByFirst: boolean} (acceptedByFirst is true if A accepts\n// and B rejects, false if A rejects and B accepts. In other cases s is not a witness\n// to A and B being different.)\n// If no witness is found, returns null. (So you can use this in an `if` if you don't\n// care what the witness is.)\n// 'count' and 'length' are optional parameters specifying how many strings at each\n// length to check and the maximum length of strings to check respectively.\n// Default count is 10 and length is 20.\n// If 'deterministic' is true, the RNG used will be deterministic.\n// If 'skipAsserts' is true, will not bother checking that generated strings are parsed. TODO don't both with asserts at all.\n// Ends up wasting some time generating duplicates at low lengths, but whatever.\n// TODO: for efficiency, should use the ftables from generator to limit how count at\n// a given length\nfunction locatableDifference(A, B, count, length, deterministic, skipAsserts) {\n  count = count || 10;\n  length = length || 20;\n  if(length < 0 || count < 1) return false;\n  \n  var oldProduceCount = parser.PRODUCECOUNT;\n  parser.PRODUCECOUNT = parser.PRODUCEONE;\n  \n  function witness(s, which) {\n    parser.PRODUCECOUNT = oldProduceCount; // found a witness: done, so reset. yeah, probably shouldn't go here.\n    return {string: s, acceptedByFirst: which};\n  }\n  \n  var genA = generator(A, deterministic);\n  var genB = generator(B, deterministic);\n  \n  for(var n=0; n<length; ++n) {\n    // first, check that they both either do or do not produce any strings of this length\n    var a = genA(n);\n    var b = genB(n);\n    if(a === null && b === null) {\n      continue; // not gonna get any strings; move on.\n    }\n    else if(a !== null && b === null) {\n      if(!skipAsserts) assert(parser.parse(A, a).length === 1, 'Generated a string \"' + a + '\" which did not parse.');\n      return witness(a, true);\n    }\n    else if(a === null && b !== null) {\n      if(!skipAsserts) assert(parser.parse(B, b).length === 1, 'Generated a string \"' + b + '\" which did not parse.');\n      return witness(b, false);\n    }\n    // ok, at least some strings in each.\n    // strictly speaking, could compare a and b here, but whatever.\n    for(var i=0; i<count; ++i) {\n      a = genA(n);\n      if(parser.parse(B, a).length !== 1) {\n        return witness(a, true);\n      }\n      \n      b = genB(n);\n      if(parser.parse(A, b).length !== 1) {\n        return witness(b, false);\n      }\n    }\n  }\n  \n  parser.PRODUCECOUNT = oldProduceCount;\n  return null;\n}\n\n\nmodule.exports.locatableDifference = locatableDifference;","var INDENT = '  ';\nfunction subtreePrinter(state, depth) {\n  depth = depth | 0;\n  var prefix = '';\n  for(var i=0; i<depth; ++i) {\n    prefix += INDENT;\n  }\n  console.log(prefix + state.rule)// + ' ' + state.backPointers.length);\n  prefix += INDENT;\n  for(var i=0; i<state.backPointers.length; ++i) {\n    var backPointer = state.backPointers[i];\n    if(backPointer === null) { // ie, terminal\n      console.log(prefix + state.rule.production[i].data); \n    }\n    else {\n      subtreePrinter(backPointer, depth+1);\n    }\n  }\n}\n\n\nfunction rewritePrinter(parse) {\n  var str = [parse];\n  \n  function formatIntermediateString(highlightIndex) { // highlightIndex must be a state, not a final symbol\n    var o = '';\n    for(var i=0; i<str.length; ++i) {\n      if(i == highlightIndex) {\n        o += '*' + str[i].rule.name + '*';\n      }\n      else {\n        if(typeof str[i] === 'string') {\n          o += str[i];\n        }\n        else {\n          o += str[i].rule.name;\n        }\n      }\n    }\n    return o;\n  }\n  \n  for(var i = 0; i<str.length; ++i) { // NB: both str.length and i change within the rewrite\n    if(typeof str[i] === 'string') {\n      continue;\n    }\n    \n    var state = str[i];\n    var out = state.rule.toString() + '  |  ';\n    out += formatIntermediateString(i) + '  |  ';\n    \n    var rewritten = [];\n    for(var j=0; j<state.index; ++j) {\n      if(state.rule.production[j].type == 'T') {\n        rewritten.push(state.rule.production[j].data);\n      }\n      else {\n        rewritten.push(state.backPointers[j]);\n      }\n    }\n    str = str.slice(0, i).concat(rewritten).concat(str.slice(i+1));\n    out += formatIntermediateString(-1);\n    console.log(out);\n    --i; // gotta reprocess the index we just rewrote\n  }\n  \n}\n\n\nfunction astPrinter(parse, collapseUnitProductions, discardImplicitTerminals, ruleRenamingFunction) {\n  // collapseUnitProductions defaults to false. If true, rules of the form X->Y will not generate an additional level in the AST.\n  // discardImplicitTerminals: if a production contains both terminals and nonterminals, children does not contain the terminals.\n  // ruleRenamingFunction should be a function from Rules in the grammar to names of rules (e.g. strings), which will then be used as the 'type' of nodes. If not present, 'type' will be the Rule itself.\n  // Non-terminals in the resulting AST have 'type' and 'children' properties, with 'children' being an array. Terminals have type 'Terminal' and a 'value' property containing their value.\n  \n  var rename = typeof ruleRenamingFunction === 'function';\n  \n  function backPointerToSubtree(bp) {\n    if (collapseUnitProductions && bp.backPointers.length === 1) {\n      var child = bp.backPointers[0];\n      if (child === null) {\n        return {\n          type: 'Terminal',\n          value: bp.rule.production[0].data\n        };\n      } else {\n        return backPointerToSubtree(child);\n      }\n    }\n    var tree = {\n      type: rename ? ruleRenamingFunction(bp.rule) : bp.rule,\n      children: []\n    }\n    var keepTerminals = !(discardImplicitTerminals && bp.backPointers.some(function(c){return c!== null;}));\n    for (var i = 0; i<bp.backPointers.length; ++i) {\n      var current = bp.backPointers[i];\n      if (current === null) {\n        if (keepTerminals) {\n          tree.children.push({\n            type: 'Terminal',\n            value: bp.rule.production[i].data\n          });\n        }\n      } else {\n        tree.children.push(backPointerToSubtree(current));\n      }\n    }\n    return tree;\n  }\n  return backPointerToSubtree(parse.backPointers[0]);\n}\n\n\n// Helper for domRule and domGrammar\n// Returns a span representing a RHS.\nfunction domProduction(production) {\n  var o = document.createElement('span');\n  if(production.length == 0) {\n    o.appendChild(document.createTextNode('\\u025B')); // epsilon\n  }\n  else {\n    for(var i=0; i<production.length; ++i) {\n      if(production[i].type == 'T') {\n        o.appendChild(document.createTextNode(production[i].data));\n      }\n      else {\n        var sp = document.createElement('span');\n        sp.className = 'cfg-symbol';\n        sp.appendChild(document.createTextNode(production[i].data));\n        o.appendChild(sp);\n      }\n    }\n  }\n  return o;\n}\n\n// helper for domPrinter\n// create a DOM node representing the rule. obviously only call in browsers.\n// symbols get class cfg-symbol, the rule itself class cfg-rule.\nfunction domRule(rule) {\n  var o = document.createElement('span');\n  o.className = 'cfg-rule';\n  \n  var sp = document.createElement('span');\n  sp.className = 'cfg-symbol';\n  sp.appendChild(document.createTextNode(rule.name));\n  o.appendChild(sp);\n  o.appendChild(document.createTextNode(' \\u2192 ')); // right arrow\n  \n  o.appendChild(domProduction(rule.production));\n    \n  return o;\n}\n\n// create a DOM table representing the entire parse. obviously only call in browsers.\nfunction domPrinter(parse) {\n  var str = [parse];\n  \n  function formatIntermediateString(highlightStart, highlightLength) {\n    if(typeof highlightLength !== 'number' || highlightLength < 0) highlightLength = 1;\n    \n    var o = document.createElement('span');\n    c = o;\n    for(var i=0; i<str.length; ++i) {\n      if(i == highlightStart) {\n        c = document.createElement('span');\n        c.className = 'cfg-rewrite';\n        o.appendChild(c);\n      }\n      \n      if(i - highlightStart >= highlightLength) {\n        c = o;\n      }\n      \n      if(typeof str[i] === 'string') {\n        c.appendChild(document.createTextNode(str[i]));\n      }\n      else {\n        var sp = document.createElement('span');\n        sp.className = 'cfg-symbol';\n        sp.appendChild(document.createTextNode(str[i].rule.name));\n        c.appendChild(sp);\n      }\n    }\n    return o;\n  }\n\n  var out = document.createElement('table');\n  out.className = 'cfg-derivations derivations'; // TODO second is for compat\n  out.innerHTML = '<thead><tr><th>Rule</th><th>Application</th><th>Result</th></tr></thead>';\n  \n  \n  // handle GAMMA state specially\n  var row = document.createElement('tr');\n  var cell = document.createElement('td');\n  var sp = document.createElement('sp');\n  sp.className = 'cfg-rule';\n  sp.innerHTML = 'Start \\u2192 ' + '<span class=\"cfg-symbol\">' + parse.backPointers[0].rule.name + '</span>';\n  cell.appendChild(sp);\n  row.appendChild(cell);\n\n  cell = document.createElement('td');\n  var sp = document.createElement('span');\n  sp.className = 'cfg-start';\n  sp.appendChild(document.createTextNode('Start'));\n  cell.appendChild(sp);\n  row.appendChild(cell);\n  \n  str = [parse.backPointers[0]]; // ie, start symbol\n  cell = document.createElement('td');\n  cell.appendChild(formatIntermediateString(-1));\n  row.appendChild(cell);\n  \n  out.appendChild(row);\n\n  \n  for(var i = 0; i<str.length; ++i) { // NB: both str.length and i change within the body of the loop\n    if(typeof str[i] === 'string') {\n      continue;\n    }\n    \n    var state = str[i];\n\n    var row = document.createElement('tr');\n    var cell = document.createElement('td');\n    cell.appendChild(domRule(state.rule));\n    row.appendChild(cell);\n  \n    cell = document.createElement('td');\n    cell.appendChild(formatIntermediateString(i));\n    row.appendChild(cell);\n    \n\n    \n    var rewritten = [];\n    for(var j=0; j<state.index; ++j) {\n      if(state.rule.production[j].type == 'T') {\n        rewritten.push(state.rule.production[j].data);\n      }\n      else {\n        rewritten.push(state.backPointers[j]);\n      }\n    }\n    str = str.slice(0, i).concat(rewritten).concat(str.slice(i+1));\n\n    cell = document.createElement('td');\n    cell.appendChild(formatIntermediateString(i, rewritten.length));\n    row.appendChild(cell);\n    out.appendChild(row);\n\n    --i; // gotta reprocess the index we just rewrote\n  }\n  \n  return out;\n}\n\n\n\nfunction escapeHTML(str) {\n  // not my preferred solution, but whatever.\n  var div = document.createElement('div');\n  div.appendChild(document.createTextNode(str));\n  return div.innerHTML;\n}\n\n// create a DOM div representing the entire parse. obviously only call in browsers.\nfunction domGrammarPrinter(grammar) {\n  var o = document.createElement('div');\n  var line = document.createElement('span');\n  line.innerHTML = 'Start symbol: <span class=\"cfg-symbol\">' + escapeHTML(grammar.start) + '</span>';\n  o.appendChild(line);\n  o.appendChild(document.createElement('br'));\n  \n  for(var i=0; i<grammar.symbolsList.length; ++i) {\n    var sym = grammar.symbolsList[i];\n    line = document.createElement('span');\n    var sp = document.createElement('span');\n    sp.className = 'cfg-symbol';\n    sp.appendChild(document.createTextNode(sym));\n    line.appendChild(sp);\n    line.appendChild(document.createTextNode(' \\u2192 '));\n    for(var j=0; j<grammar.symbolMap[sym].rules.length; ++j) {\n      if(j > 0) {\n        line.appendChild(document.createTextNode(' | '));\n      }\n      var rule = grammar.symbolMap[sym].rules[j];\n      line.appendChild(domProduction(rule.production));\n    }\n    o.appendChild(line);\n    o.appendChild(document.createElement('br'));\n  }\n  \n  return o;\n}\n\n\nmodule.exports = {\n  subtreePrinter: subtreePrinter,\n  rewritePrinter: rewritePrinter,\n  astPrinter: astPrinter,\n  domPrinter: domPrinter,\n  domGrammarPrinter: domGrammarPrinter\n}","module.exports = exports = {\n  types: require('./types'),\n  generator: require('./generate'),\n  parser: require('./parser'),\n  checks: require('./check'),\n  printers: require('./printers')\n}\n","\"use strict\";\n\n\n// TODO consider rolling an in-house Set type; this is getting absurd.\n\nfunction DFA(alphabet, delta, initial, final) {\n  /*  alphabet is a list of characters.\n      delta an object such that delta[state][sym] = state, for each (state, sym) pair.\n        Its own properties are the states of the automaton.\n      initial the name of the start state\n      final a list of accepting states */\n  // TODO automatically sanitize names?\n  this.alphabet = alphabet.slice(0)//.sort();\n  this.states = Object.getOwnPropertyNames(delta).sort();\n  this.delta = delta;\n  this.initial = initial;\n  this.final = final.slice(0)//.sort();\n  this.isMinimized = false; // internal property: was this produced by minimization?\n  \n  // todo sanity checking (cf python)\n}\n\nDFA.prototype.accepts = function(str) {\n  /* boolean: does my language contain the given string? */\n  // todo sanity checking (str in alphabet*)\n  var state = this.initial;\n  for (var i = 0; i < str.length; ++i) {\n    state = this.delta[state][str[i]];\n  }\n  return this.final.indexOf(state) !== -1;\n}\n\nDFA.prototype.test = function(str) { // alias for accepts, to match JS regex\n  return this.accepts(str);\n}\n\nDFA.prototype.to_NFA = function() {\n  /*  return the NFA which is this DFA. */\n  var newDelta = {};\n  for (var i = 0; i < this.states.length; ++i) {\n    var state = this.states[i];\n    newDelta[state] = {};\n    for (var j = 0; j < this.alphabet.length; ++j) {\n      newDelta[state][this.alphabet[j]] = [this.delta[state][this.alphabet[j]]];\n    }\n  }\n  return new NFA(this.alphabet, newDelta, [this.initial], this.final);\n}\n\nDFA.prototype.minimized = function() {\n  /*  non-destructively return the minimal DFA equivalent to this one.\n      state names will become meaningless.\n      Brzozowski's algorithm = best algorithm */\n  var out = this.to_NFA().reversed().to_DFA().to_NFA().reversed().to_DFA();\n  out.isMinimized = true;\n  return out;\n}\n\nDFA.prototype.without_unreachables = function() { // todo naming conventions\n  /*  non-destructively produce equivalent DFA without unreachable states */\n  var reached = {};\n  crawl(this.alphabet, this.initial, this.delta, {state_fn: function(s){reached[s]=true;}});\n  \n  var newDelta = {};\n  var newStates = Object.getOwnPropertyNames(reached);\n  for (var i = 0; i < newStates.length; ++i) {\n    newDelta[newStates[i]] = this.delta[newStates[i]];\n  }\n  var newFinal = this.final.filter(reached.hasOwnProperty.bind(reached));\n  return new DFA(this.alphabet, newDelta, this.initial, newFinal);\n}\n\nDFA.prototype.complemented = function() {\n  /*  non-destructively produce DFA accepting exactly the strings this does not */\n  var final = this.final;\n  return new DFA(this.alphabet, this.delta, this.initial, this.states.filter(function(s){return final.indexOf(s) === -1;}));\n}\n\nDFA.prototype.find_passing = function() {\n  /*  Returns one of the shortest strings which will be accepted by the DFA, if such exists.\n      Otherwise returns null. */\n  return crawl(this.alphabet, this.initial, this.delta, {should_exit: function(s){return this.final.indexOf(s) !== -1;}.bind(this)});\n}\n\nDFA.prototype.intersect = function(other) {\n  /*  Return a DFA for the language which is the intersection of this machine's and other's.\n      `other` must be over the same alphabet. */\n  // todo sanity checking (alphabets)\n  function get_name(pair) {\n    return this.states.indexOf(pair[0]) + ' ' + other.states.indexOf(pair[1]);\n  }\n  get_name = get_name.bind(this);\n\n  var initial = [this.initial, other.initial];\n  var newFinal = [];\n  var newDelta = {};\n\n  var thiz = this;\n  function follow(state, sym) {\n    var next = [thiz.delta[state[0]][sym], other.delta[state[1]][sym]];\n    newDelta[get_name(state)][sym] = get_name(next);\n    return next;\n  }\n\n  function state_fn(state) {\n    var curName = get_name(state);\n    newDelta[curName] = {};\n    if (thiz.final.indexOf(state[0]) !== -1 && other.final.indexOf(state[1]) !== -1) {\n      newFinal.push(curName);\n    }\n  }\n\n  crawl(this.alphabet, initial, follow, {get_name: get_name, state_fn: state_fn});\n\n  return new DFA(this.alphabet, newDelta, get_name(initial), newFinal);\n}\n\nDFA.prototype.find_equivalence_counterexamples = function(other) {\n  /*  Return a pair of strings such that the first string is accepted by the first machine,\n      but not the second, and the second string is accepted by the second, but not the first.\n      If no such string exists in either case, the corresponding value will be null.\n      Hence, if machines are equivalent, returns [null, null]. TODO can also check equivalence by comparing serializations\n      `other` must be over the same alphabet. */\n  return [\n    this.intersect(other.complemented()).find_passing(),\n    other.intersect(this.complemented()).find_passing()\n  ];\n}\n\nDFA.prototype.dottified = function() {\n  /*  Return a string representation of this DFA as a graph in Dot format. */\n  var out = 'digraph foo {\\n  rankdir=LR;\\n  \"__start\" [style=invis label=\"\" shape=plain];\\n  node [shape=circle];';\n  var thiz = this;\n  this.states.filter(function(s){return thiz.final.indexOf(s) == -1;}).forEach(function(state){\n    out += ' \"' + reprEscape(state) + '\";';\n  });\n  out += '\\n  node [shape = doublecircle];';\n  this.final.forEach(function(state){\n    out += ' \"' + reprEscape(state) + '\";';\n  });\n  out += '\\n  \"__start\" -> \"' + reprEscape(this.initial) + '\";';\n  this.states.forEach(function(state){\n    var edges = {};\n    thiz.states.forEach(function(s){\n      edges[s] = [];\n    });\n    thiz.alphabet.forEach(function(c){\n      edges[thiz.delta[state][c]].push(c);\n    });\n    thiz.states.forEach(function(target){\n      if (edges[target].length === 0) {\n        return;\n      }\n      out += '\\n  \"' + reprEscape(state) +\n              '\" -> \"' + reprEscape(target) +\n              '\" [label=\"' + edges[target].map(reprEscape).join(',') + '\"];'\n    });\n  });\n  out += '\\n}\\n';\n  return out;\n}\n\nDFA.prototype.serialized = function() {\n  /*  Give a string representing a JSON serialization of this DFA, discarding state names and unreachable states.\n      Deterministic in the following strong sense: if two DFAs are identical up to state\n      names, then they will serialize to the same string. */\n\n  // canonically order states\n  var newStates = [];\n  crawl(this.alphabet, this.initial, this.delta, {state_fn: function(s){newStates.push(s);}});\n\n  // then serialize using said order\n  function get_name(state) {\n    /*  Helper: state -> canonical name */\n    return newStates.indexOf(state);\n  }\n  var alphabet = this.alphabet.slice(0).sort();\n  var deltaStr = '{';\n  for (var i = 0; i < newStates.length; ++i) {\n    if (i !== 0) {\n      deltaStr += ', ';\n    }\n    deltaStr += '\"' + i + '\": {';\n    for (var j = 0; j < alphabet.length; ++j) {\n      var sym = alphabet[j];\n      if (j !== 0) {\n        deltaStr += ', ';\n      }\n      deltaStr += '\"' + reprEscape(sym) + '\": \"' + get_name(this.delta[newStates[i]][sym]) + '\"';\n    }\n    deltaStr += '}';\n  }\n  deltaStr += '}';\n  \n  var out = '{';\n  out += '\"alphabet\": [' + alphabet.map(reprEscape).map(function(c){return '\"' + c + '\"';}).join(',') + '], ';\n  out += '\"delta\": ' + deltaStr + ', ';\n  out += '\"initial\": \"' + get_name(this.initial) + '\", ';\n  out += '\"final\": [' + this.final.map(get_name).sort().map(function(c){return '\"' + c + '\"';}).join(',') + ']}';\n  return out;\n}\n\n\n\nfunction NFA(alphabet, delta, initial, final) {\n  /*  alphabet is a list of characters.\n      delta an object such that delta[state][sym] = list of states\n        Its own properties are the states of the automaton.\n        the epsilon transition is held to be the empty string. so delta[state][''] should also be a list of states.\n        it is permissible for delta[state][sym] to be undefined, which will be interpreted as the empty set.\n      initial a list of start states (in our formalism, multiple start states are allowed; this is obviously equivalent and simplifies some operations, like reversal)\n      final a list of accepting states */\n  this.alphabet = alphabet.slice(0)//.sort();\n  this.states = Object.getOwnPropertyNames(delta).sort();\n  this.delta = delta;\n  this.initial = initial.slice(0)//.sort(); // maybe should be epsilon closure'd?\n  this.final = final.slice(0)//.sort();\n  \n  // todo sanity checking (cf python)\n}\n\nNFA.prototype.epsilon_closure = function(states) {\n  /*  Mainly an internal method.\n      Given a set of states, return the set of states reachable via 0 or more epsilon transitions from those states.\n      Incidentally also deduplicates. */\n  var out = deduped(states);\n  var processing = out.slice(0);\n  while (processing.length > 0) {\n    var cur = processing.pop();\n    var next = this.delta[cur][''];\n    if (next === undefined) {\n      continue;\n    }\n    for (var i = 0; i < next.length; ++i) {\n      if (processing.indexOf(next[i]) === -1 && out.indexOf(next[i]) === -1) { // TODO consider alternatives to indexOf\n        processing.push(next[i]);\n        out.push(next[i]);\n      }\n    }\n  }\n  return out;\n}\n\nNFA.prototype.step = function(states, sym) {\n  /*  Given a set of states and a symbol, give the result of running the machine\n      for one step. As a prerequisite, states should be equal to its own epsilon closure.\n      Takes epsilon closure at the end. */\n  // todo sanity checking? (sym in alphabet)\n  var delta = this.delta;\n  states = states.map(function(state) {\n    var out = delta[state][sym];\n    if (out === undefined) {\n      return [];\n    }\n    return out;\n  });\n  if (states.length === 0) {\n    return states;\n  }\n  states = states.reduce(function(a, b) { return a.concat(b); }); // no flatmap, so map + flatten.\n  return this.epsilon_closure(states);\n}\n\nNFA.prototype.accepts = function(str) {\n  /* boolean: does my language contain the given string? */\n  // todo sanity checking (str in alphabet*)\n  var states = this.epsilon_closure(this.initial);\n  for (var i = 0; i < str.length; ++i) {\n    states = this.step(states, str[i]);\n  }\n  for (i = 0; i < this.final.length; ++i) {\n    if (states.indexOf(this.final[i]) !== -1) {\n      return true;\n    }\n  }\n  return false;\n}\n\nNFA.prototype.test = function(str) { // alias for accepts, to match JS regex\n  return this.accepts(str);\n}\n\nNFA.prototype.to_DFA = function() {\n  /*  Return an equivalent DFA. State names become meaningless. */\n  function get_name(states) {\n    /*  Helper: set of states -> canonical (string) name */\n    return states.map(this.states.indexOf.bind(this.states)).sort().join(' ');\n  }\n  get_name = get_name.bind(this);\n\n  var initial = this.epsilon_closure(this.initial);\n  var newFinal = [];\n  var newDelta = {};\n\n  var thiz = this;\n  function follow(state, sym) {\n    var next = thiz.step(state, sym);\n    newDelta[get_name(state)][sym] = get_name(next);\n    return next;\n  }\n\n  function state_fn(state) {\n    var curName = get_name(state);\n    newDelta[curName] = {};\n    for (var i = 0; i < thiz.final.length; ++i) {\n      if (state.indexOf(thiz.final[i]) !== -1) { // i.e., state contains an accepting state\n        newFinal.push(curName);\n        break;\n      }\n    }\n  }\n\n  crawl(this.alphabet, initial, follow, {get_name: get_name, state_fn: state_fn});\n  return new DFA(this.alphabet, newDelta, get_name(initial), newFinal);\n}\n\nNFA.prototype.minimized = function() {\n  /*  non-destructively return the minimal DFA equivalent to this automata.\n      state names will become meaningless. */\n  return this.to_DFA().minimized();\n}\n\nNFA.prototype.reversed = function() {\n  /*  non-destructively return the NFA given by reversing all arrows and swapping initial with final.\n      The result will accept the reverse of the language of this machine, i.e., all strings whose reverse is accepted by this machine. */\n  var newDelta = {};\n  for (var i = 0; i < this.states.length; ++i) {\n    newDelta[this.states[i]] = {};\n  }\n  \n  for (i = 0; i < this.states.length; ++i) {\n    var state = this.states[i];\n    for (var j = 0; j <= this.alphabet.length; ++j) {\n      var sym = (j == this.alphabet.length) ? '' : this.alphabet[j];\n      var res = this.delta[state][sym];\n      if (res === undefined) {\n        continue;\n      }\n      for (var k = 0; k < res.length; ++k) { // todo three nested loops is almost certainly not the best way to do this.\n        var existing = newDelta[res[k]][sym];\n        newDelta[res[k]][sym] = (existing === undefined) ? [state] : deduped(existing.concat([state])); // todo could just update in-place\n      }\n    }\n  }\n  return new NFA(this.alphabet, newDelta, this.final, this.initial);\n}\n\nNFA.prototype._clone = function(prefix) {\n  /*  Internal method. Return a copy of this automaton.\n      State names will become integers prefixed with 'prefix'. */ // TODO keep old names?\n  function get_name(state) {\n    /*  Helper: state -> canonical name */\n    return '' + prefix + this.states.indexOf(state);\n  }\n  get_name = get_name.bind(this);\n\n  var newDelta = {};\n  for (var i = 0; i < this.states.length; ++i) {\n    var state = this.states[i];\n    var curName = get_name(state);\n    newDelta[curName] = {};\n    for (var j = 0; j <= this.alphabet.length; ++j) {\n      var sym = (j == this.alphabet.length) ? '' : this.alphabet[j];\n      var res = this.delta[state][sym];\n      if (res === undefined) {\n        continue;\n      }\n      newDelta[curName][sym] = res.map(get_name);\n    }\n  }\n  return new NFA(this.alphabet, newDelta, this.initial.map(get_name), this.final.map(get_name));\n}\n\nNFA.prototype.concat = function(other) {\n  /*  Give an NFA for the language given by concatenating all strings from this machine's\n      language with all strings from other's language. E.g., if 'x' only accepts strings\n      of a's and y only accepts strings of b's, the result accepts any string of a's\n      followed by 'b's.\n      `other` must be over the same alphabet. */\n  // todo sanity checking (alphabets)\n  var newThis = this._clone('q');\n  var newThat = other._clone('r'); // these two machines now do not have conflicting state names.\n  \n  for (var i = 0; i < newThat.states.length; ++i) {\n    var state = newThat.states[i];\n    newThis.delta[state] = newThat.delta[state];\n  }\n  \n  for (i = 0; i < newThis.final.length; ++i) {\n    var state = newThis.final[i];\n    var cur = newThis.delta[state][''];\n    if (cur === undefined) {\n      cur = newThis.delta[state][''] = [];\n    }\n    for (var j = 0; j < newThat.initial.length; ++j) {\n      cur.push(newThat.initial[j]);\n    }\n  }\n  \n  return new NFA(this.alphabet, newThis.delta, newThis.initial, newThat.final);\n}\n\nNFA.prototype.union = function(other) {\n  /*  Give an NFA for the language containing all strings in this machine's\n      language and all strings in other's language. E.g., if 'x' only accepts strings\n      of a's and y only accepts strings of b's, the result accepts any string of a's\n      or any string of 'b's.\n      `other` must be over the same alphabet. */\n  // todo sanity checking (alphabets)\n  var newThis = this._clone('q');\n  var newThat = other._clone('r'); // these two machines now do not have conflicting state names.\n  \n  for (var i = 0; i < newThat.states.length; ++i) {\n    var state = newThat.states[i];\n    newThis.delta[state] = newThat.delta[state];\n  }\n  // TODO the above code is duplicated in concat\n  \n  newThis.delta['s'] = {'': newThis.initial.concat(newThat.initial)};\n  \n  return new NFA(this.alphabet, newThis.delta, ['s'], newThis.final.concat(newThat.final));\n}\n\nNFA.prototype.star = function() {\n  /*  Give the Kleene star of this NFA. */\n  var newThis = this._clone('q');\n  newThis.delta['s'] = {'': newThis.initial};\n  for (var i = 0; i < newThis.final.length; ++i) {\n    var state = newThis.final[i];\n    var cur = newThis.delta[state][''];\n    if (cur === undefined) {\n      cur = newThis.delta[state][''] = [];\n    }\n    cur.push('s');\n  }\n  return new NFA(newThis.alphabet, newThis.delta, ['s'], ['s']);\n}\n\nNFA.prototype.plus = function() {\n  /*  Give the Kleene plus of this NFA. */\n  var newThis = this._clone('q');\n  for (var i = 0; i < newThis.final.length; ++i) {\n    var state = newThis.final[i];\n    var cur = newThis.delta[state][''];\n    if (cur === undefined) {\n      cur = newThis.delta[state][''] = [];\n    }\n    for (var j = 0; j < newThis.initial.length; ++j) {\n      cur.push(newThis.initial[j]);\n    }\n    //cur.splice(cur.length, 0, newThis.initial);\n  }\n  return newThis;\n}\n\nNFA.prototype.repeat = function(n) {\n  /* Given the NFA produced by repeating this NFA a finite number of times. */\n  if (n < 0) {\n    throw 'Can\\'t repeat a negative number of times (' + n + ')';\n  } else if (n === 0) {\n    return NFA.for('', this.alphabet);\n  } else if (n === 1) {\n    return this;\n  } else {\n    return this.concat(this.repeat(n-1));\n  }\n}\n\nNFA.prototype.optional = function() {\n  /*  Give an NFA which is equivalent to this, but also accepts the empty string.\n      Corresponds to the '?' operator on regular expressions. */\n  var newThis = this._clone('q');\n  newThis.delta['s'] = {'': newThis.initial};\n  return new NFA(newThis.alphabet, newThis.delta, ['s'], newThis.final.concat(['s']));\n}\n\nNFA.for = function(str, alphabet) {\n  /*  Construct an NFA which matches exactly the string given. */\n  // TODO check str in alphabet*\n  var cur = 's';\n  var delta = {'s': {}};\n  for (var i = 0; i < str.length; ++i) {\n    var next = 'q' + (i+1);\n    delta[cur][str[i]] = [next];\n    delta[next] = {};\n    cur = next;\n  }\n  return new NFA(alphabet, delta, ['s'], [cur]);\n}\n\n// TODO serialize NFA?\n\nNFA.prototype.dottified = function() {\n  /*  Return a string representation of this NFA as a graph in Dot format.\n      For technical reasons, epsilon transitions are represented as '_'. */\n  var out = 'digraph foo {\\n  rankdir=LR;\\n  \"__start\" [style=invis label=\"\" shape=plain];\\n  node [shape=circle];';\n  var thiz = this;\n  this.states.filter(function(s){return thiz.final.indexOf(s) == -1;}).forEach(function(state){\n    out += ' \"' + reprEscape(state) + '\";';\n  });\n  out += '\\n  node [shape = doublecircle];';\n  this.final.forEach(function(state){\n    out += ' \"' + reprEscape(state) + '\";';\n  });\n  this.initial.forEach(function(state){\n    out += '\\n  \"__start\" -> \"' + reprEscape(state) + '\";';\n  });\n  this.states.forEach(function(state){\n    var edges = {};\n    thiz.states.forEach(function(s){\n      edges[s] = [];\n    });\n    thiz.alphabet.concat('').forEach(function(c){\n      var transitions = thiz.delta[state][c];\n      if (transitions === undefined) {\n        return;\n      }\n      if (c === '') {\n        c = '_';\n      }\n      transitions.forEach(function(target){\n        edges[target].push(c);\n      });\n    });\n    thiz.states.forEach(function(target){\n      if (edges[target].length === 0) {\n        return;\n      }\n      out += '\\n  \"' + reprEscape(state) +\n              '\" -> \"' + reprEscape(target) +\n              '\" [label=\"' + edges[target].map(reprEscape).join(',') + '\"];'\n    });\n  });\n  out += '\\n}\\n';\n  return out;\n}\n\n\n// library stuff\n\nfunction deduped(l) { // non-destructively remove duplicates from list. also sorts.\n  return l.filter(function(val, index, arr) { return arr.indexOf(val) == index; }).sort();\n}\n\nfunction reprEscape(str) { // does not handle unicode or exceptional cases properly.\n  return str.replace(/[\"\\\\]/g, function(c) { return '\\\\' + c; })\n    .replace(/\\n/g, '\\\\n').replace(/\\r/g, '\\\\r');\n}\n\nfunction crawl(alphabet, initial, follow, options) {\n  /*  Walk an automaton graph.\n      Follow should be either a function from state, sym to state, or a DFA delta object.\n      Options are state_fn, which is run once for each state encountered,\n      get_name, which is a map from states to their names (so that the actual state objects can be complex)\n      and should_exit, which takes a state and returns a boolean; if true, crawl immediately returns the string which caused that state to be reached.\n      Otherwise returns null. */\n  var state_fn = options.state_fn || function(){};\n  var get_name = options.get_name || function(x){return x;};\n  var should_exit = options.should_exit || function(){return false;};\n\n  if (should_exit(initial)) {\n    return '';\n  }\n\n  if (typeof follow === \"object\") {\n    var delta = follow;\n    follow = function(state, sym) {\n      return delta[state][sym];\n    }\n  }\n\n  var reached = Object.create(null);\n  reached[get_name(initial)] = '';\n  var processing = [initial];\n  while (processing.length > 0) {\n    var cur = processing.shift();\n    var curName = get_name(cur);\n    state_fn(cur);\n    for (var i = 0; i < alphabet.length; ++i) {\n      var sym = alphabet[i];\n      var next = follow(cur, sym);\n      var nextName = get_name(next);\n      if (should_exit(next)) {\n        return reached[cur] + sym;\n      }\n      if (reached[nextName] === undefined) {\n        reached[nextName] = reached[curName] + sym;\n        processing.push(next);\n      }\n    }\n  }\n  return null;\n}\n\n\nmodule.exports.NFA = NFA;\nmodule.exports.DFA = DFA;\n","var gtool = require('cfgrammar-tool');\nvar lib = require('./dfa-lib');\nvar NFA = lib.NFA;\n\nvar astPrinter = gtool.printers.astPrinter;\nvar parser = gtool.parser;\nvar { Grammar, Rule, NT, T } = gtool.types;\n\nvar rules = [\n  Rule('U', [NT('C'), T('|'), NT('U')]), // union\n  Rule('U', [T('|'), NT('U')]),\n  Rule('U', []),\n  Rule('U', [NT('C')]),\n  Rule('C', [NT('O'), NT('C')]), // concatenation\n  Rule('C', [NT('O')]),\n  Rule('O', [NT('R'), T('?')]), // option\n  Rule('O', [NT('R')]),\n  Rule('R', [NT('A'), T('*')]), // repetition\n  Rule('R', [NT('A'), T('+')]),\n  Rule('R', [NT('A'), T('^'), NT('I')]),\n  Rule('R', [NT('A')]),\n  Rule('A', [T('('), NT('U'), T(')')]), // atom\n  Rule('A', [NT('L')]),\n  Rule('I', [NT('D')]), // int\n  Rule('I', [NT('I'), NT('D')]),\n  Rule('D', [T('0')]),\n  Rule('D', [T('1')]),\n  Rule('D', [T('2')]),\n  Rule('D', [T('3')]),\n  Rule('D', [T('4')]),\n  Rule('D', [T('5')]),\n  Rule('D', [T('6')]),\n  Rule('D', [T('7')]),\n  Rule('D', [T('8')]),\n  Rule('D', [T('9')]),\n];\n\nfunction ruleNamer(rule) { // strictly speaking, this could be folded in to to_NFA, but it's nice to make a readable AST.\n  switch (rules.indexOf(rule)) {\n    case 0:\n      return 'Union';\n    case 1:\n      return 'EmptyUnion';\n    case 2:\n      return 'Empty';\n    case 4:\n      return 'Concatenation';\n    case 6:\n      return 'Option';\n    case 8:\n      return 'Star';\n    case 9:\n      return 'Plus';\n    case 10:\n      return 'Repetition';\n    case 12:\n      return 'Paren';\n    case 15:\n      return 'Digits';\n    default:\n      throw 'Unreachable: ' + rules.indexOf(rule);\n  }\n}\n\n\nfunction parse(regex, alphabet) {\n  var grammar = Grammar(rules.concat(alphabet.map(function(c){ return Rule('L', [T(c)]); })), 'U');\n  var res = parser.parse(grammar, regex);\n  if (res.length !== 1) throw 'Couldn\\'t unambiguously parse: ' + res.length;\n  return astPrinter(res[0], true, true, ruleNamer);\n}\n\nfunction guessAlphabet(regex) {\n  return regex.replace(/[\\|\\*\\+\\^\\?\\(\\)0-9]/g, '').split('').filter(function(c,i,s){return s.indexOf(c)===i;}).sort();\n}\n\nfunction to_NFA(regex, alphabet) {\n  if (typeof alphabet === 'undefined') {\n    alphabet = guessAlphabet(regex);\n  } else if (typeof alphabet === 'string') {\n    alphabet = alphabet.split('');\n  }\n  function reduce(tree) {\n    switch (tree.type) {\n      case 'Union':\n        return reduce(tree.children[0]).union(reduce(tree.children[1]));\n      case 'EmptyUnion':\n        return reduce(tree.children[0]).optional();\n      case 'Empty':\n        return NFA.for('', alphabet);\n      case 'Concatenation':\n        return reduce(tree.children[0]).concat(reduce(tree.children[1]));\n      case 'Option':\n        return reduce(tree.children[0]).optional();\n      case 'Star':\n        return reduce(tree.children[0]).star();\n      case 'Plus':\n        return reduce(tree.children[0]).plus();\n      case 'Repetition':\n        return reduce(tree.children[0]).repeat(parseInt(reduceDigits(tree.children[1])));\n      case 'Paren':\n        return reduce(tree.children[0]);\n      case 'Terminal':\n        return NFA.for(tree.value, alphabet);\n      default:\n        throw 'Unreachable: ' + tree.type;\n    }\n  }\n\n  function reduceDigits(tree) { // Note: string concatenation\n    if (tree.type === 'Digits') {\n      return reduceDigits(tree.children[0]) + reduceDigits(tree.children[1]);\n    } else { // Terminal\n      return tree.value;\n    }\n  }\n\n  return reduce(parse(regex, alphabet));\n}\n\n\n// TODO: to_regex, just on principle\n\nmodule.exports = to_NFA;\nmodule.exports.parse = parse;\n","var to_NFA = require('./regex');\n\nfunction $(s){\n  return document.querySelector(s);\n}\n\nfunction hideAll() {\n  $('#equiv-div').style.display = 'none';\n  $('#error-div').style.display = 'none';\n  $('#unequiv-div').style.display = 'none';\n  $('#both-error').style.display = 'none';\n  $('#first-error').style.display = 'none';\n  $('#second-error').style.display = 'none';\n  $('#first-accept-div').style.display = 'none';\n  $('#second-accept-div').style.display = 'none';\n}\n\nfunction show(ele) {\n  ele.style.display = 'inline';\n}\n\nfunction parse(s1) {\n  try {\n    return to_NFA(s1);\n  } catch(e) {\n    return null;\n  }\n}\n\nfunction union(l1, l2) {\n  return l1.concat(l2).filter(function(v, i, a){return a.indexOf(v) === i}).sort();\n}\n\nfunction update() {\n  hideAll();\n\n  var m1 = parse($('#regex-1').value.replace(/\\s/g, ''));\n  var m2 = parse($('#regex-2').value.replace(/\\s/g, ''));\n\n  if (!m1 || !m2) {\n    show($('#error-div'));\n    if (!m1 && !m2) {\n      show($('#both-error'));\n    } else if (!m1) {\n      show($('#first-error'));\n    } else {\n      show($('#second-error'));\n    }\n    return;\n  }\n\n  m1.alphabet = m2.alphabet = union(m1.alphabet, m2.alphabet);\n  m1 = m1.minimized();\n  m2 = m2.minimized();\n\n  var strings = m1.find_equivalence_counterexamples(m2);\n\n  if (strings[0] === null && strings[1] === null) {\n    show($('#equiv-div'));\n  } else {\n    show($('#unequiv-div'));\n\n    strings = strings.map(function(s){return s === '' ? '[empty string]' : s});\n\n    if (strings[0] !== null) {\n      show($('#first-accept-div'));\n      $('#first-accept-pre').textContent = strings[0];\n    }\n\n    if (strings[1] !== null) {\n      show($('#second-accept-div'));\n      $('#second-accept-pre').textContent = strings[1];\n    }\n  }\n}\n\naddEventListener('load', function(){\n  $('#regex-1').addEventListener('input', update);\n  $('#regex-2').addEventListener('input', update);\n  update();\n});\n"],"names":["Sym","type","data","this","reprEscape","str","replace","c","Rule","name","production","Grammar","rules","start","symbolMap","symbolsList","i","length","sym","push","j","rhsSym","prototype","equals","other","toString","join","repr","out","getReverseMap","hasOwnProperty","_reverseMap","rule","types","NT","T","assert","condition","message","Error","require$$0","sum","l","choose","r","total","t","console","log","generate","grammar","deterministic","deNulled","empty","annotateSelfDeriving","seed","rand","Math","random","ftable","f","n","fprime","fprimetable","k","x","tij","g","gprime","concat","opts","asList","list","makesEpsilon","outList","findLength","range","findLengths","lengths","require$$1","nthSubset","p","annotateNullables","nullables","queue","cs","rMap","nullable","maybeNullable","_index","cur","pop","affected","annotateUnreachables","unreachables","unreachable","annotateUseless","uselesses","useless","selfDerivings","derives","o","nonnullable","selfDeriving","strippedUseless","newRules","newGrammar","strippedUnreachable","strippedUnitProductions","done","enqueue","seen","origRule","newRule","slice","strippedDuplicates","stripped","nullableRHSIndices","skipFinal","lastSubset","pow","skippedSubset","newProduction","indexOf","alphabet","forEach","s","sort","require$$2","parser","enums","State","index","predecessor","backPointers","PRODUCEONE","PRODUCETWO","PRODUCEALL","PRODUCECOUNT","compare","a","b","arraysEqual","next","parse","produceCount","oldProduceCount","chart","state","strPos","count","equalness","scanner","newBPs","advanced","predictor","candidate","completer","thisSym","prevState","startSym","gammaRule","parses","parser_1","generator","check","locatableDifference","A","B","skipAsserts","witness","which","string","acceptedByFirst","genA","genB","domProduction","document","createElement","appendChild","createTextNode","sp","className","domRule","printers","subtreePrinter","depth","prefix","backPointer","rewritePrinter","formatIntermediateString","highlightIndex","rewritten","astPrinter","collapseUnitProductions","discardImplicitTerminals","ruleRenamingFunction","rename","backPointerToSubtree","bp","child","value","tree","children","keepTerminals","some","current","domPrinter","highlightStart","highlightLength","innerHTML","row","cell","domGrammarPrinter","div","line","exports","checks","require$$3","require$$4","DFA","delta","initial","final","states","Object","getOwnPropertyNames","isMinimized","NFA","deduped","filter","val","arr","crawl","follow","options","state_fn","get_name","should_exit","reached","create","processing","shift","curName","nextName","undefined","accepts","test","to_NFA","newDelta","minimized","reversed","to_DFA","without_unreachables","newStates","newFinal","bind","complemented","find_passing","intersect","pair","thiz","find_equivalence_counterexamples","dottified","edges","target","map","serialized","deltaStr","epsilon_closure","NFA$1","step","reduce","res","existing","_clone","newThis","newThat","union","star","plus","repeat","for","optional","transitions","dfaLib","gtool","Rule$1","ruleNamer","regex","regexModule","reduceDigits","split","guessAlphabet","parseInt","$","querySelector","show","ele","style","display","s1","e","update","l1","l2","m1","m2","v","strings","textContent","addEventListener"],"mappings":"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"}